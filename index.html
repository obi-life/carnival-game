<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bubble Pop Gauge Kids Coordination Game</title>
  <style>
    :root {
      --bg: #eaf6ff;
      --ink: #0b1b2b;
      --muted: #6a7b8c;
      --card: #ffffff;
      --accent: #4f9cff;
      --accent-2: #7ad0ff;
      --good: #2fbf71;
      --warn: #ffb020;
      --bad: #ff5a6f;
      --shadow: 0px 10px 30px rgba(0, 0, 0, 0.08), 0px 2px 8px rgba(0, 0, 0, 0.06);
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto,
        Ubuntu, Cantarell, "Noto Sans", "Helvetica Neue", Arial,
        "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--ink);
      background: radial-gradient(
        1200px 800px at 20% -10%,
        #dff3ff,
        var(--bg) 40%,
        #f7fbff 72%,
        linear-gradient(180deg, #f7fbff, var(--bg))
      );
    }
    .shell {
      max-width: 1100px;
      margin: 0 auto;
      padding: 24px;
      min-height: 100%;
      display: grid;
      grid-template-rows: auto auto 1fr auto;
      gap: 16px;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 800;
      letter-spacing: 0.2px;
    }
    .logo {
      width: 40px;
      height: 40px;
      border-radius: 12px;
      display: grid;
      place-items: center;
      box-shadow: var(--shadow);
      background: radial-gradient(120% 120% at 20% 20%, #ffffff, #d7f1ff 40%, #a9e0ff);
    }
    .card {
      background: var(--card);
      border-radius: 20px;
      box-shadow: var(--shadow);
      padding: 16px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .controls input[type='text'],
    .controls select,
    .controls input[type='number'] {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #d7e3ef;
      outline: none;
      font-size: 14px;
    }
    .btn {
      cursor: pointer;
      border: 0;
      border-radius: 14px;
      padding: 10px 16px;
      font-weight: 700;
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
      color: white;
      box-shadow: var(--shadow);
    }
    .btn.secondary {
      background: #f0f6ff;
      color: #195a9b;
    }
    .hud {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      align-items: center;
    }
    .gauge-wrap {
      position: relative;
      height: 20px;
      background: #e6f1ff;
      border-radius: 12px;
      overflow: hidden;
    }
    .gauge-bar {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #47c6ff, #57e2ff, #a7ffeb);
      transition: width 0.2s ease;
    }
    .gauge-tip {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #00405a;
      font-weight: 700;
    }
    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .pill {
      background: #f2f7ff;
      border: 1px solid #dbe9fb;
      padding: 8px 10px;
      border-radius: 999px;
      font-size: 12px;
    }
    .playzone {
      position: relative;
      min-height: 70vh;
      max-height: 600px;
      border-radius: 24px;
      overflow: hidden;
      background: radial-gradient(
        120% 100% at 50% -10%,
        #e6f1ff 0,
        #d4f1ff 60%,
        #bde7ff 100%
      );
      box-shadow: var(--shadow);
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
    }
    .overlay .panel {
      pointer-events: auto;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(8px);
      padding: 18px;
      border-radius: 18px;
      box-shadow: var(--shadow);
      max-width: 680px;
    }
    .overlay h2 {
      margin: 0 0 8px 0;
    }
    .overlay p {
      margin: 8px 0;
      color: var(--muted);
    }
    .results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 10px;
    }
    .metric {
      background: #f7fbff;
      border: 1px solid #e1edf8;
      border-radius: 16px;
      padding: 12px;
    }
    .metric h4 {
      margin: 0 0 6px 0;
      font-size: 14px;
    }
    .metric .big {
      font-size: 24px;
      font-weight: 900;
    }
    .personality {
      margin-top: 12px;
      font-weight: 600;
      font-size: 16px;
      color: var(--accent);
    }
    footer {
      color: var(--muted);
      font-size: 12px;
      text-align: center;
      padding-bottom: 10px;
    }
    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .fullscreen-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      cursor: pointer;
      border: 0;
      border-radius: 10px;
      padding: 8px;
      background: linear-gradient(180deg, var(--accent), var(--accent-2));
      color: white;
      box-shadow: var(--shadow);
      font-size: 14px;
    }
    .fs-timer {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      color: #00405a;
      font-size: 18px;
      font-weight: 700;
      background: rgba(255,255,255,0.5);
      padding: 4px 8px;
      border-radius: 8px;
      display: none;
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="brand">
        <div class="logo">üíß</div>
        Bubble Pop Gauge
        <small style="color: var(--muted); font-weight: 600"
          >Hand-Eye Coordination for Kids</small
        >
      </div>
    </header>

    <section class="controls card">
      <input id="playerName" type="text" placeholder="Child's name" />
      <select id="iconPicker" title="Choose icon">
        <option>üêù Bee</option>
        <option>üåû Sun</option>
        <option>üåü Star</option>
        <option>üçÄ Clover</option>
        <option>üêæ Paw</option>
        <option>üê¶ Bird</option>
        <option>‚ú® Sparkle</option>
        <option>üåà Rainbow</option>
        <option>‚≠ê Star</option>
        <option>üê¨ Dolphin</option>
        <option>ü¶ã Butterfly</option>
        <option>üåª Flower</option>
      </select>
      <label for="gameTime">Time (seconds):</label>
      <input id="gameTime" type="number" value="45" min="15" max="180" />
      <label for="bubbleCount">Bubble count:</label>
      <input id="bubbleCount" type="number" value="7" min="1" max="25" />
      <label for="playerAge">Age (years):</label>
      <input id="playerAge" type="number" value="5" min="1" max="18" />
      <button class="btn" id="startBtn">Start</button>
      <button
        class="btn secondary"
        id="downloadBtn"
        title="Download CSV of last results"
      >
        Export CSV
      </button>
    </section>

    <section class="hud">
      <div class="card">
        <div class="gauge-wrap" aria-label="Time remaining">
          <div class="gauge-bar" id="timeBar"></div>
          <div class="gauge-tip" id="timeTip">Ready</div>
        </div>
      </div>
      <div class="stats">
        <span class="pill" id="pillHits">Hits: 0</span>
        <span class="pill" id="pillMiss">Misses: 0</span>
        <span class="pill" id="pillAcc">Accuracy: 0%</span>
        <span class="pill" id="pillRT">Avg RT: 0 ms</span>
        <span class="pill" id="pillTPM">Targets/min: 0</span>
        <span class="pill" id="pillStreak">Streak: 0</span>
      </div>
    </section>

    <section class="playzone card">
      <button class="fullscreen-btn" id="fullscreenBtn">‚õ∂ Fullscreen</button>
      <div class="fs-timer" id="fsTimer">Time left: 0s</div>
      <canvas id="scene"></canvas>

      <div class="overlay" id="overlay">
        <div class="panel">
          <h2>Pop the bubbles!</h2>
          <p>Tap or click the bubbles that show your name icon. Other bubbles are decoys. Pop as many as you can before time runs out.</p>
          <div
            class="row"
            style="justify-content: space-between; align-items: center"
          >
            <div style="font-size: 13px; color: var(--muted)">
              Metrics captured: <strong>hand-eye score</strong>,
              <strong>accuracy</strong>, <strong>reaction time</strong>,
              <strong>targets/min</strong>, <strong>streak</strong>,
              <strong>misses</strong>.
            </div>
            <button class="btn" id="bigStart">Start Game</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="results" style="display:none">
        <div class="panel">
          <h2>
            Great job, <span id="resName">Player</span>!
          </h2>
          <p>Here are your results:</p>
          <div class="results-grid" id="resultsGrid"></div>
          <div class="personality" id="personalityDesc"></div>
          <div
            class="row"
            style="justify-content: space-between; align-items: center; margin-top: 8px"
          >
            <div style="font-size: 12px; color: var(--muted)">
              Scores are saved locally on this device.
            </div>
            <div>
              <button class="btn secondary" id="playAgain">Play again</button>
              <button class="btn" id="exportCsv">Export CSV</button>
            </div>
          </div>
        </div>
      </div>
    </section>
    <footer>
      Bubble visuals use gradients & specular highlights to look like real bubbles. Works offline. Host anywhere, static Netlify-ready.
    </footer>
  </div>

  <audio id="bgMusic" src="audio/piano.mp3" loop></audio>
  <audio id="popSound" src="audio/error2.mp3"></audio>

  <script>
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a, b) => Math.random() * (b - a) + a;
    const now = () => performance.now();

    const canvas = document.getElementById("scene");
    const ctx = canvas.getContext("2d");
    const dpr = window.devicePixelRatio || 1;

    function resizeCanvas() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
      }
    }

    const colorsRainbow = [
      "rgba(255, 0, 0, ALPHA)", // Red
      "rgba(255, 127, 0, ALPHA)", // Orange
      "rgba(255, 255, 0, ALPHA)", // Yellow
      "rgba(0, 255, 0, ALPHA)", // Green
      "rgba(0, 0, 255, ALPHA)", // Blue
      "rgba(75, 0, 130, ALPHA)", // Indigo
      "rgba(148, 0, 211, ALPHA)", // Violet
    ];

    let bubbles = [];
    let running = false;
    let startTime = 0;
    let durationMs = 45000;
    let spawnCount = 7;
    let speedMul = 1.0;
    let decoyRatio = 0.5;

    const metrics = {
      hits: 0,
      misses: 0,
      streak: 0,
      bestStreak: 0,
      targetSpawns: 0,
      reactionTimes: [],
      taps: 0,
    };

    let colorIndex = 0;

    function resetMetrics() {
      metrics.hits = 0;
      metrics.misses = 0;
      metrics.streak = 0;
      metrics.bestStreak = 0;
      metrics.targetSpawns = 0;
      metrics.reactionTimes.length = 0;
      metrics.taps = 0;
      colorIndex = 0;
    }

    function getProfile() {
      const name = document.getElementById("playerName").value.trim();
      const icon = document.getElementById("iconPicker").value;
      return { name, icon };
    }

    class Bubble {
      constructor(x, y, r, vx, vy, text, icon, isTarget, color) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.vx = vx;
        this.vy = vy;
        this.text = text;
        this.icon = icon;
        this.isTarget = isTarget;
        this.birth = now();
        this.alpha = 0;
        this.color = color;
      }

      update(dt) {
        this.x += this.vx * dt * speedMul;
        this.y += this.vy * dt * speedMul;

        this.vx += Math.sin(now()) * 0.001 - 0.001;
        this.vy += 0;

        if (this.x - this.r < 0) {
          this.x = this.r;
          this.vx = Math.abs(this.vx);
        }
        if (this.x + this.r > canvas.clientWidth) {
          this.x = canvas.clientWidth - this.r;
          this.vx = -Math.abs(this.vx);
        }
        if (this.y - this.r < 0) {
          this.y = this.r;
          this.vy = Math.abs(this.vy);
        }
        if (this.y + this.r > canvas.clientHeight) {
          this.y = canvas.clientHeight - this.r;
          this.vy = -Math.abs(this.vy);
        }

        const age = now() - this.birth;
        this.alpha = clamp(age / 400, 0, 1);
      }

      draw(ctx) {
        const baseColor = this.color.replace("ALPHA", (this.alpha * 0.8).toFixed(2));
        const grd = ctx.createRadialGradient(
          this.x - this.r * 0.4,
          this.y - this.r * 0.4,
          this.r * 0.2,
          this.x,
          this.y,
          this.r
        );
        grd.addColorStop(0, `rgba(255, 255, 255, ${this.alpha * 0.9})`);
        grd.addColorStop(0.5, baseColor);
        grd.addColorStop(1, `rgba(135, 206, 235, ${this.alpha * 0.2})`);

        ctx.save();
        ctx.globalAlpha = this.alpha;

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fillStyle = grd;
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.strokeStyle = "rgba(180, 220, 255, 0.9)";
        ctx.stroke();

        ctx.beginPath();
        ctx.ellipse(
          this.x - this.r * 0.35,
          this.y - this.r * 0.35,
          this.r * 0.4,
          this.r * 0.2,
          -0.6,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        ctx.fill();

        ctx.fillStyle = "#08324a";
        ctx.font = `bold ${Math.max(16, this.r * 0.5)}px system-ui`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.icon, this.x, this.y - this.r * 0.1);

        ctx.font = `600 ${Math.max(12, this.r * 0.25)}px system-ui`;
        ctx.fillText(this.text, this.x, this.y + this.r * 0.3);

        ctx.restore();
      }

      contains(px, py) {
        const dx = px - this.x;
        const dy = py - this.y;
        return Math.hypot(dx, dy) <= this.r;
      }
    }

    function randomBubble(isTarget) {
      const margin = 60;
      const r = rand(28, 60);
      const x = rand(margin, canvas.clientWidth - margin);
      const y = rand(margin, canvas.clientHeight - margin);
      const vx = rand(-0.08, 0.08);
      const vy = rand(-0.02, 0.02);
      const profile = getProfile();
      const decoyIcons = [
        "üêù",
        "üåû",
        "üåü",
        "üçÄ",
        "üêæ",
        "üê¶",
        "‚ú®",
        "üåà",
        "‚≠ê",
        "üê¨",
        "ü¶ã",
        "üåª",
      ];
      const decoyNames = [
        "Sun",
        "Sky",
        "Joy",
        "Bee",
        "Kit",
        "Pip",
        "Zee",
        "Mio",
      ];

      const text = isTarget ? profile.name || "You" : decoyNames[Math.floor(rand(0, decoyNames.length))];
      const icon = isTarget ? profile.icon || "‚≠ê" : decoyIcons[Math.floor(rand(0, decoyIcons.length))];

      if (isTarget) metrics.targetSpawns++;

      const color = colorsRainbow[colorIndex % colorsRainbow.length];
      colorIndex++;

      return new Bubble(x, y, r, vx, vy, text, icon, isTarget, color);
    }

    let last = now();
    function loop() {
      if (!running) return;
      const t = now();
      const dt = t - last;
      last = t;

      const elapsed = t - startTime;
      const remaining = clamp(durationMs - elapsed, 0, durationMs);
      const pct = (remaining / durationMs) * 100;
      document.getElementById("timeBar").style.width = pct + "%";
      const timeText = remaining > 0 ? `Time left: ${(remaining / 1000).toFixed(1)}s` : "Done";
      document.getElementById("timeTip").textContent = timeText;
      document.getElementById("fsTimer").textContent = timeText;

      if (remaining <= 0) {
        endGame();
        return;
      }

      bubbles = bubbles.filter((b) => now() - b.birth < 2000);

      const hasTarget = bubbles.some((b) => b.isTarget);

      while (bubbles.length < spawnCount) {
        const isTarget = hasTarget ? Math.random() > decoyRatio : true;
        bubbles.push(randomBubble(isTarget));
      }

      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      for (const b of bubbles) {
        b.update(dt);
      }
      for (const b of bubbles) {
        b.draw(ctx);
      }

      requestAnimationFrame(loop);
    }

    function handleTap(clientX, clientY) {
      if (!running) return;
      metrics.taps++;

      const rect = canvas.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;

      for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        if (b.contains(x, y)) {
          if (b.isTarget) {
            const rt = now() - b.birth;
            metrics.hits++;
            metrics.streak++;
            metrics.bestStreak = Math.max(metrics.bestStreak, metrics.streak);
            metrics.reactionTimes.push(rt);
          } else {
            metrics.misses++;
            metrics.streak = 0;
          }

          const popAudio = document.getElementById("popSound");
          if (popAudio) {
            popAudio.currentTime = 0;
            popAudio.play();
          }

          bubbles.splice(i, 1);
          setTimeout(() => {
            if (running) {
              const hasTargetNow = bubbles.some((b) => b.isTarget);
              const isTarget = hasTargetNow ? Math.random() > decoyRatio : true;
              bubbles.push(randomBubble(isTarget));
            }
          }, 200);

          refreshPills();
          return;
        }
      }

      metrics.misses++;
      metrics.streak = 0;
      const popAudio = document.getElementById("popSound");
      if (popAudio) {
        popAudio.currentTime = 0;
        popAudio.play();
      }
      refreshPills();
    }

    canvas.addEventListener("click", (e) => handleTap(e.clientX, e.clientY));
    canvas.addEventListener("touchstart", (e) => {
      const te = e.changedTouches[0];
      handleTap(te.clientX, te.clientY);
    });

    function avg(arr) {
      return arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
    }

    function refreshPills() {
      const acc = (metrics.hits / Math.max(1, metrics.taps)) * 100;
      const tpm = (metrics.targetSpawns / Math.max(1, now() - startTime)) * 60000;
      const avgRT = avg(metrics.reactionTimes);

      document.getElementById("pillHits").textContent = "Hits: " + metrics.hits;
      document.getElementById("pillMiss").textContent = "Misses: " + metrics.misses;
      document.getElementById("pillAcc").textContent = "Accuracy: " + acc.toFixed(0) + "%";
      document.getElementById("pillRT").textContent = metrics.reactionTimes.length
        ? "Avg RT: " + avgRT.toFixed(0) + " ms"
        : "Avg RT: 0 ms";
      document.getElementById("pillTPM").textContent = isFinite(tpm)
        ? "Targets/min: " + tpm.toFixed(1)
        : "Targets/min: 0";
      document.getElementById("pillStreak").textContent = `Streak: ${metrics.streak}`;
    }

    function calcFinalScore() {
      const acc = metrics.hits / Math.max(1, metrics.taps);
      const avgRT = avg(metrics.reactionTimes);
      const streakScore = clamp(metrics.bestStreak / 10, 0, 1);
      const rtScore = clamp((3000 - avgRT) / 3000, 0, 1);

      let score = acc * 50 + rtScore * 30 + streakScore * 20;

      return Math.round(score);
    }

    function detectPersonality() {
      const age = clamp(parseInt(document.getElementById("playerAge").value), 1, 18);
      const youngPersonalities = [
        "Curious explorer! You love trying everything.",
        "Bright spark! Your energy lights up the game.",
        "Steady star! You keep going with great focus.",
        "Playful adventurer! You dive into the fun.",
        "Quick learner! You're catching on fast.",
        "Joyful jumper! You make every pop count.",
        "Bouncy buddy! Your enthusiasm is awesome."
      ];
      const olderPersonalities = [
        "Sharp strategist! You plan your moves well.",
        "Lightning leader! Your speed is impressive.",
        "Focused force! Your precision stands out.",
        "Bold blaster! You tackle challenges head-on.",
        "Steady striker! You maintain great control.",
        "Dynamic driver! Your energy powers through.",
        "Resilient racer! You keep pushing forward."
      ];

      const personalities = age < 12 ? youngPersonalities : olderPersonalities;
      return personalities[Math.floor(Math.random() * personalities.length)];
    }

    function startGame() {
      resizeCanvas();
      const secs = parseInt(document.getElementById("gameTime").value) || 45;
      const age = clamp(parseInt(document.getElementById("playerAge").value), 1, 18);

      durationMs = secs * 1000;
      spawnCount = Math.round(5 + ((age - 1) / (18 - 1)) * (20 - 5));
      speedMul = 0.8 + ((age - 1) / (18 - 1)) * (4.0 - 0.8);

      resetMetrics();
      bubbles.length = 0;
      for (let i = 0; i < spawnCount; i++) {
        bubbles.push(randomBubble(i === 0));
      }

      startTime = now();
      running = true;
      last = now();

      document.getElementById("overlay").style.display = "none";
      document.getElementById("results").style.display = "none";
      refreshPills();

      const bgMusic = document.getElementById("bgMusic");
      if (bgMusic) {
        bgMusic.currentTime = 0;
        bgMusic.play();
      }

      loop();
    }

    function endGame() {
      running = false;

      const bgMusic = document.getElementById("bgMusic");
      if (bgMusic && !bgMusic.paused) {
        bgMusic.pause();
        bgMusic.currentTime = 0;
      }

      const finalScore = calcFinalScore();
      const personality = detectPersonality();

      showResults({
        player: getProfile(),
        metrics: {
          score: finalScore,
          hits: metrics.hits,
          misses: metrics.misses,
          taps: metrics.taps,
          accuracyPct: ((metrics.hits / Math.max(1, metrics.taps)) * 100).toFixed(1),
          avgReactionMs: Math.round(avg(metrics.reactionTimes)),
          bestStreak: metrics.bestStreak,
        },
        personality,
        settings: {
          durationSec: durationMs / 1000,
          spawnCount,
          speedMul,
        },
      });

      saveResult({
        timestamp: new Date().toISOString(),
        player: getProfile(),
        metrics: {
          score: finalScore,
          hits: metrics.hits,
          misses: metrics.misses,
          taps: metrics.taps,
          accuracyPct: ((metrics.hits / Math.max(1, metrics.taps)) * 100).toFixed(1),
          avgReactionMs: Math.round(avg(metrics.reactionTimes)),
          bestStreak: metrics.bestStreak,
        },
        personality,
        settings: {
          durationSec: durationMs / 1000,
          spawnCount,
          speedMul,
        },
      });
    }

    function showResults(data) {
      document.getElementById("resName").textContent =
        (data.player.icon ?? "‚≠ê") + " " + (data.player.name || "Player");
      const G = document.getElementById("resultsGrid");
      G.innerHTML = "";
      const add = (label, value) => {
        const el = document.createElement("div");
        el.className = "metric";
        el.innerHTML = `<h4>${label}</h4><div class="big">${value}</div>`;
        G.appendChild(el);
      };
      add("Score (max 100)", data.metrics.score);
      add("Hits", data.metrics.hits);
      add("Misses", data.metrics.misses);
      add("Accuracy", data.metrics.accuracyPct + "%");
      add("Avg Reaction Time", data.metrics.avgReactionMs + " ms");
      add("Best Streak", data.metrics.bestStreak);

      document.getElementById("personalityDesc").textContent =
        "Personality: " + data.personality;

      document.getElementById("overlay").style.display = "grid";
      document.getElementById("results").style.display = "grid";
    }

    const LSKEY = "bubble-pop-results-v1";

    function saveResult(obj) {
      const all = JSON.parse(localStorage.getItem(LSKEY)) || [];
      all.push(obj);
      localStorage.setItem(LSKEY, JSON.stringify(all));
      window.lastResult = obj;
    }

    function exportCSV(single = false) {
      const entries = single
        ? [window.lastResult]
        : JSON.parse(localStorage.getItem(LSKEY)) || [];
      if (!entries.length) {
        alert("No results to export yet. Play a game first!");
        return;
      }
      const headers = [
        "timestamp",
        "name",
        "icon",
        "durationSec",
        "spawnCount",
        "speed",
        "score",
        "hits",
        "misses",
        "taps",
        "accuracyPct",
        "avgReactionMs",
        "bestStreak",
        "personality",
      ];
      const rows = entries.map((e) =>
        [
          e.timestamp,
          e.player.name,
          e.player.icon,
          e.settings.durationSec,
          e.settings.spawnCount,
          e.settings.speedMul,
          e.metrics.score,
          e.metrics.hits,
          e.metrics.misses,
          e.metrics.taps,
          e.metrics.accuracyPct,
          e.metrics.avgReactionMs,
          e.metrics.bestStreak,
          e.personality.replace(/,/g, ";"),
        ].join(",")
      );
      const csv = [headers.join(","), ...rows].join("\n");
      const blob = new Blob([csv], { type: "text/csv" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "bubble-pop-results.csv";
      a.click();
    }

    document.getElementById("startBtn").addEventListener("click", startGame);
    document.getElementById("bigStart").addEventListener("click", startGame);
    document.getElementById("playAgain").addEventListener("click", () => {
      document.getElementById("overlay").style.display = "grid";
      document.getElementById("results").style.display = "none";
    });
    document.getElementById("exportCsv").addEventListener("click", () => exportCSV(true));
    document.getElementById("downloadBtn").addEventListener("click", () => exportCSV(false));

    document.getElementById("fullscreenBtn").addEventListener("click", () => {
      const playzone = document.querySelector(".playzone");
      if (!document.fullscreenElement) {
        playzone.requestFullscreen().catch((err) => {
          console.error(`Error attempting to enable fullscreen: ${err.message}`);
        });
      } else {
        document.exitFullscreen();
      }
    });

    document.addEventListener("fullscreenchange", () => {
      resizeCanvas();
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const fsTimer = document.getElementById("fsTimer");
      if (document.fullscreenElement) {
        fullscreenBtn.textContent = "‚õ∂ Exit Fullscreen";
        fsTimer.style.display = "block";
      } else {
        fullscreenBtn.textContent = "‚õ∂ Fullscreen";
        fsTimer.style.display = "none";
      }
    });

    window.addEventListener('resize', resizeCanvas);

    resizeCanvas();
    document.getElementById("overlay").style.display = "grid";
  </script>
</body>
</html>
